import "vidstack/styles/defaults.css";
import "vidstack/styles/community-skin/video.css";
import { defineCustomElements } from "vidstack/elements";

declare module "solid-js" {
  namespace JSX {
    interface IntrinsicElements {
      "media-player": any;
      "media-outlet": any;
      "media-poster": any;
      "media-captions": any;
      "media-community-skin": any;
    }
  }
}

import {
  HLSErrorEvent,
  MediaCanPlayEvent,
  MediaOutletElement,
  MediaPlayerElement,
  MediaPosterElement,
  MediaProviderChangeEvent,
  VideoProvider,
  isHLSProvider,
  // MediaPlayerConnectEvent,
} from "vidstack";
import {
  For,
  ParentProps,
  Show,
  children,
  createEffect,
  createMemo,
  createSignal,
  lazy,
  on,
  onCleanup,
  onMount,
  useContext,
} from "solid-js";
import { PlayerContext, PreferencesContext } from "~/root";
import { PipedVideo, PreviewFrame, RelatedStream, Subtitle } from "~/types";
import { chaptersVtt } from "~/utils/chapters";
import { useIsRouting, useLocation, useNavigate } from "solid-start";
// import { extractVideoId } from "~/routes/watch";
// import { RouteLocation, useLocation } from "@builder.io/qwik-city";
// import { IDBPDatabase } from "idb";
// import PlayerSkin from "./player-skin/player-skin";
import { extractVideoId } from "~/routes/watch";
import { DBContext } from "~/root";
//@ts-ignore
import { ttml2srt } from "~/utils/ttml";
import PlayerSkin from "./PlayerSkin";
import VideoCard from "./VideoCard";
import { videoId } from "~/routes/history";
import numeral from "numeral";
import { useQueue } from "~/stores/queueStore";
import { usePlaylist } from "~/stores/playlistStore";
import dayjs from "dayjs";
import { Dispose } from "maverick.js";

const BUFFER_LIMIT = 3;
const BUFFER_TIME = 15000;
const TIME_SPAN = 300000;
export default function Player() {
  console.log(new Date().toISOString().split("T")[1], "rendering player");
  console.time("rendering player");
  const [video] = useContext(PlayerContext);
  //   const db = useContext(DBContext);
  const route = useLocation();
  let mediaPlayer: MediaPlayerElement | undefined = undefined;
  const [db] = useContext(DBContext);
  const updateProgress = () => {
    console.log("updating progress");
    if (!video.value) return;
    if (!started()) {
      console.log("not started , updating");
      return;
    }
    let currentTime = mediaPlayer?.currentTime;
    if (video.value.category === "Music") {
      currentTime = 0;
    }
    const tx = db()?.transaction("watch_history", "readwrite");
    const store = tx?.objectStore("watch_history");
    if (!store) return;
    const id = videoId(video.value);
    if (!id) return;

    let isShort = false;
    let width = video.value.videoStreams?.[0]?.width;
    let height = video.value.videoStreams?.[0]?.height;
    if (width && height) {
      isShort = height > width;
    }

    const val = {
      title: video.value.title,
      duration: video.value.duration,
      thumbnail: video.value.thumbnailUrl,
      uploaderName: video.value.uploader,
      uploaderAvatar: video.value.uploaderAvatar,
      uploaderUrl: video.value.uploaderUrl,
      url: `/watch?v=${id}`,
      isShort,
      progress: currentTime,
      watchedAt: new Date().getTime(),
    };
    console.log("updating progress", val);

    store.put(val, id);
    console.log(
      `updated progress for ${video.value.title}. ${id} to ${currentTime}`
    );
  };

  const [preferences, setPreferences] = useContext(PreferencesContext);
  const [playlist] = usePlaylist();

  const queueStore = useQueue();

  const [vtt, setVtt] = createSignal<string | undefined>(undefined);

  const [error, setError] = createSignal<{
    name: string;
    details: string;
    fatal: boolean;
    message: string;
    code: number | undefined;
  }>();

  const [tracks, setTracks] = createSignal<
    {
      id: string;
      key: string;
      kind: string;
      src: string;
      srcLang: string;
      label: string;
      dataType: string;
    }[]
  >([]);

  const [subtitles, setSubtitles] = createSignal<Map<string, string>>();

  const fetchSubtitles = async (subtitles: Subtitle[]) => {
    console.time("fetching subtitles");
    const newTracks = await Promise.all(
      subtitles.map(async (subtitle) => {
        if (!subtitle.url) return null;
        if (subtitle.mimeType !== "application/ttml+xml")
          return {
            id: `track-${subtitle.code}`,
            key: subtitle.url,
            kind: "subtitles",
            src: subtitle.url,
            srcLang: subtitle.code,
            label: `${subtitle.name} - ${subtitle.autoGenerated ? "Auto" : ""}`,
            dataType: subtitle.mimeType,
          };
        const { srtUrl, srtText } = await ttml2srt(subtitle.url);
        // remove empty subtitles
        if (srtText.trim() === "") return null;
        return {
          id: `track-${subtitle.code}`,
          key: subtitle.url,
          kind: "subtitles",
          src: srtUrl,
          srcLang: subtitle.code,
          label: `${subtitle.name} - ${subtitle.autoGenerated ? "Auto" : ""}`,
          dataType: "srt",
        };
      })
    );
    console.timeEnd("fetching subtitles");
    setTracks(newTracks.filter((track) => track !== null) as any);
  };

  const initMediaSession = () => {
    if (!navigator.mediaSession) return;
    if (!video.value) return;
    if (!mediaPlayer) return;
    navigator.mediaSession.metadata = new MediaMetadata({
      title: video.value.title,
      artist: video.value.uploader,
      artwork: [
        {
          src: video.value?.thumbnailUrl,
          sizes: "128x128",
          type: "image/png",
        },
      ],
    });
    navigator.mediaSession.setActionHandler("play", () => {
      mediaPlayer?.play();
    });
    navigator.mediaSession.setActionHandler("pause", () => {
      mediaPlayer?.pause();
    });
    navigator.mediaSession.setActionHandler("seekbackward", () => {
      mediaPlayer!.currentTime -= 10;
    });
    navigator.mediaSession.setActionHandler("seekforward", () => {
      mediaPlayer!.currentTime += 10;
    });
    navigator.mediaSession.setActionHandler("previoustrack", () => {
      mediaPlayer!.currentTime -= 10;
    });
    navigator.mediaSession.setActionHandler("nexttrack", () => {
      mediaPlayer!.currentTime += 10;
    });
    navigator.mediaSession.setActionHandler("stop", () => {
      console.log("stop");
    });
  };

  const setMediaState = () => {
    navigator.mediaSession.setPositionState({
      duration: video.value!.duration,
      playbackRate: mediaPlayer!.playbackRate,
      position: mediaPlayer!.currentTime,
    });
  };

  const init = () => {
    if (!video.value) return;
    console.time("init");
    initMediaSession();
    fetchSubtitles(video.value.subtitles);
    if (!video.value?.subtitles) return;
    const subs = new Map<string, string>();
    video.value.subtitles.forEach((subtitle) => {
      if (!subtitle.url) return;
      subs.set(subtitle.code, subtitle.url);
    });
    setSubtitles(subs);
  };

  const [currentTime, setCurrentTime] = createSignal(0);
  const time = route.query.t;
  const [started, setStarted] = createSignal(false);

  const onCanPlay = (event: Event) => {
    console.log("can play", route.search.match("fullscreen"));
    console.log(event);
    setError(undefined);
    init();
    if (!video.value?.chapters) return;
    if (!mediaPlayer) return;
    if (route.search.match("fullscreen")) {
      if (navigator.userActivation.isActive) {
        mediaPlayer?.requestFullscreen();
      }
    }
    let chapters = [];
    for (let i = 0; i < video.value.chapters.length; i++) {
      const chapter = video.value.chapters[i];
      const name = chapter.title;
      // seconds to 00:00:00
      const timestamp = new Date(chapter.start * 1000)
        .toISOString()
        .slice(11, 22);
      const seconds =
        video.value.chapters[i + 1]?.start - chapter.start ??
        video.value.duration - chapter.start;
      chapters.push({ name, timestamp, seconds });
    }

    setVtt(chaptersVtt(chapters, video.value.duration));
    if (vtt()) {
      mediaPlayer.textTracks.add({
        kind: "chapters",
        default: true,
        content: vtt(),
        type: "vtt",
      });
    }

    if (time) {
      let start = 0;
      if (/^[\d]*$/g.test(time)) {
        start = parseInt(time);
      } else {
        const hours = /([\d]*)h/gi.exec(time)?.[1];
        const minutes = /([\d]*)m/gi.exec(time)?.[1];
        const seconds = /([\d]*)s/gi.exec(time)?.[1];
        if (hours) {
          start += parseInt(hours) * 60 * 60;
        }
        if (minutes) {
          start += parseInt(minutes) * 60;
        }
        if (seconds) {
          start += parseInt(seconds);
        }
      }
      setCurrentTime(start);
      // this.initialSeekComplete = true;
    }
  };

  createEffect(() => {
    if (!video.value) return;
    if (!mediaPlayer) return;
    mediaPlayer.thumbnails = generateStoryboard(video.value.previewFrames[1]);
    console.log(mediaPlayer.thumbnails);
  });

  createEffect(() => {
    console.log("time effect", video.value?.title);
    if (!video.value) return;
    if (!mediaPlayer) return;
    if (!db()) return;
    if (time) return;
    const tx = db()!.transaction("watch_history", "readonly");
    const store = tx.objectStore("watch_history");
    const id = videoId(video.value);
    console.log(id, "id time");
    if (!id) return;
    store.get(id).then((v) => {
      if (!video.value) return;
      console.log(v, "val time");
      const progress = v?.progress;
      if (progress) {
        if (progress < video.value.duration * 0.9) {
          console.log("seeking to time", progress);
          setCurrentTime(progress);
        }
      }
      console.timeEnd("init");
    });
  });

  createEffect(() => {
    const nextVideo = video.value?.relatedStreams?.[0];
    if (!nextVideo) return;
    if (!mediaPlayer) return;
    if (!video.value) return;
    if (route.query.list) return;
    queueStore.setCurrentVideo({
      url: `/watch?v=${videoId(video.value)}`,
      title: video.value.title,
      thumbnail: video.value.thumbnailUrl,
      duration: video.value.duration,
      uploaderName: video.value.uploader,
      uploaderAvatar: video.value.uploaderAvatar,
      uploaderUrl: video.value.uploaderUrl,
      isShort: false,
      shortDescription: "",
      type: "video",
      uploaded: dayjs(video.value.uploadDate).unix(),
      views: video.value.views,
      uploadedDate: video.value.uploadDate,
      uploaderVerified: video.value.uploaderVerified,
    });
    if (queueStore.isCurrentLast()) {
      queueStore.addToQueue(nextVideo);
    }
  });

  const playNext = () => {
    console.log("playing next", nextVideo());
    if (!nextVideo()) return;

    navigate(nextVideo()!.url, { replace: false });
    setEnded(false);
  };

  function handleSetNextVideo() {
    console.log("setting next video");
    let url = `/watch?v=`;
    if (playlist()) {
      const local = "videos" in playlist()!;
      const listId =
        route.query.list ?? (playlist() as unknown as { id: string })!.id;
      let index; // index starts from 1
      if (route.query.index) {
        index = parseInt(route.query.index);
      } else if (local) {
        index = (playlist() as unknown as {
          videos: RelatedStream[];
        })!.videos!.findIndex((v) => videoId(v) === videoId(video.value));
        if (index !== -1) index++;
      } else {
        index = playlist()!.relatedStreams!.findIndex(
          (v) => videoId(v) === videoId(video.value)
        );
        if (index !== -1) index++;
      }

      if (index < playlist()!.relatedStreams?.length) {
        const next = playlist()!.relatedStreams[index]; // index is already +1
        url += `${videoId(next)}&list=${listId}&index=${index + 1}`;
        setNextVideo({ url: url, info: next });
      } else if (
        index <
        (playlist() as unknown as { videos: RelatedStream[] })!.videos?.length
      ) {
        const next = (playlist() as unknown as {
          videos: RelatedStream[];
        })!.videos[index]; // index is already +1
        url += `${videoId(next)}&list=${listId}&index=${index + 1}`;
        setNextVideo({
          url: url,
          info: next,
        });
      }
      return;
    }
    const next = queueStore.next();
    if (!next) return;

    setNextVideo({
      url: `/watch?v=${videoId(next)}`,
      info: next,
    });
  }
  createEffect(() => {
    if (!video.value) return;
    if (!mediaPlayer) return;
    handleSetNextVideo();
  });

  const [ended, setEnded] = createSignal(false);
  const [nextVideo, setNextVideo] = createSignal<{
    url: string;
    info: RelatedStream;
  } | null>(null);

  const handleEnded = () => {
    console.log("ended");
    if (!mediaPlayer) return;
    if (!video.value) return;
    setEnded(true);
    showToast();
    updateProgress();
  };
  const [showEndScreen, setShowEndScreen] = createSignal(false);
  const defaultCounter = 5;
  const [counter, setCounter] = createSignal(defaultCounter);
  let timeoutCounter: any;

  createEffect(() => {
    console.log("ended effect", ended());
    if (!ended()) return;
    if (!mediaPlayer) return;
    if (!video.value) return;
  });

  function showToast() {
    console.log("showing toast");
    setCounter(defaultCounter);
    if (counter() < 1) {
      console.log("counter less than 1");
      playNext();
      return;
    }
    if (timeoutCounter) clearInterval(timeoutCounter);
    timeoutCounter = setInterval(() => {
      console.log("counting", counter());
      setCounter((c) => c - 1);
      if (counter() === 0) {
        dismiss();
        playNext();
      }
    }, 1000);
    console.log("showing end screen");
    setShowEndScreen(true);
  }
  function dismiss() {
    console.log("dismiss");
    clearInterval(timeoutCounter);
    setShowEndScreen(false);
  }

  onCleanup(() => {
    clearInterval(timeoutCounter);
    document.removeEventListener("keydown", handleKeyDown);
  });

  const onProviderChange = (event: MediaProviderChangeEvent) => {
    console.log(event, "provider change");
    const provider = event.detail;
    if (isHLSProvider(provider)) {
      provider.library = () => import("hls.js");
      console.log(provider);
      provider.config = {
        startLevel: 0,
      };
    }
  };

  const handleHlsError = (err: HLSErrorEvent) => {
    console.dir(err.detail);
    setError({
      name: err.detail.error.name,
      code: err.detail.response?.code,
      details: err.detail.details,
      fatal: err.detail.fatal,
      message: err.detail.error.message,
    });
    console.log(error());
  };

  //   function selectDefaultQuality() {
  //     let preferredQuality = 1080; // TODO: get from user settings
  //     if (!mediaPlayer.value) return;
  //     console.log(mediaPlayer.value.qualities);
  //     const q = mediaPlayer.value.qualities.toArray().find((q) => q.height >= preferredQuality);
  //     console.log(q);
  //     if (q) {
  //       q.selected = true;
  //     }
  //   }
  //   const pos = {
  //     tl: "top-0 -left-72",
  //   };
  //   return (
  //     <media-player
  //   src="https://stream.mux.com/VZtzUzGRv02OhRnZCxcNg49OilvolTqdnFLEqBsTwaxU/low.mp4"
  //   poster="https://image.mux.com/VZtzUzGRv02OhRnZCxcNg49OilvolTqdnFLEqBsTwaxU/thumbnail.webp?time=268&width=980"
  //   thumbnails="https://media-files.vidstack.io/sprite-fight/thumbnails.vtt"
  //   aspect-ratio="16/9"
  //   crossorigin
  // >
  //   <media-outlet>
  //     <media-poster
  //       alt="Girl walks into sprite gnomes around her friend on a campfire in danger!"
  //     ></media-poster>
  //    <track
  //       src="https://media-files.vidstack.io/sprite-fight/subs/english.vtt"
  //       label="English"
  //       srclang="en-US"
  //       kind="subtitles"
  //       default
  //     />
  //     <track
  //       src="https://media-files.vidstack.io/sprite-fight/chapters.vtt"
  //       srclang="en-US"
  //       kind="chapters"
  //       default
  //     />
  //   </media-outlet>
  //   <media-community-skin></media-community-skin>
  // </media-player>

  //   )
  let outlet: any;
  function toggleFloating(floating: boolean) {
    const container = document.getElementById("pip-container");
    if (!container) return;
    if (floating) {
      container.append(outlet);
      if (container.classList.contains("hidden")) {
        container.classList.remove("hidden");
      }
    } else {
      if (!container.classList.contains("hidden")) {
        container.classList.add("hidden");
      }
      mediaPlayer?.prepend(outlet);
    }
  }

  onMount(() => {
    console.log("mount", mediaPlayer);
    document.addEventListener("beforeunload", updateProgress);
    document.addEventListener("visibilitychange", updateProgress);
  });
  onCleanup(() => {
    document.removeEventListener("beforeunload", updateProgress);
    document.removeEventListener("visibilitychange", updateProgress);
  });
  const isRouting = useIsRouting();
  const navigate = useNavigate();
  createEffect(() => {
    if (isRouting()) {
      console.log("routing");
      // if ("window" in globalThis) {
      //   // add fullscreen parameter
      //   const url = new URL(window.location.href);
      //   url.searchParams.set("fullscreen", "true");
      //   navigate(url.href.replace(url.origin, "").toString(), { replace: false});
      // }
      updateProgress();
    }
    // if (route.pathname !== "/watch") {
    //   toggleFloating(true);
    // } else {
    //   toggleFloating(false);
    // }
  });

  const generateStoryboard = (
    previewFrames: PreviewFrame | undefined
  ): string | null => {
    if (!previewFrames) return null;
    let output = "WEBVTT\n\n";
    let currentTime = 0;

    for (let url of previewFrames.urls) {
      for (let y = 0; y < previewFrames.framesPerPageY; y++) {
        for (let x = 0; x < previewFrames.framesPerPageX; x++) {
          if (
            currentTime >=
            previewFrames.totalCount * previewFrames.durationPerFrame
          ) {
            break;
          }

          let startX = x * previewFrames.frameWidth;
          let startY = y * previewFrames.frameHeight;

          output += `${formatTime(currentTime)} --> ${formatTime(
            currentTime + previewFrames.durationPerFrame
          )}\n`;
          output += `${url}#xywh=${startX},${startY},${previewFrames.frameWidth},${previewFrames.frameHeight}\n\n`;

          currentTime += previewFrames.durationPerFrame;
        }
      }
    }

    function formatTime(ms: number): string {
      let hours = Math.floor(ms / 3600000);
      ms -= hours * 3600000;
      let minutes = Math.floor(ms / 60000);
      ms -= minutes * 60000;
      let seconds = Math.floor(ms / 1000);
      ms -= seconds * 1000;

      return `${hours.toString().padStart(2, "0")}:${minutes
        .toString()
        .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}.${ms
        .toString()
        .padStart(3, "0")}`;
    }

    const blob = new Blob([output], { type: "text/vtt" });
    return URL.createObjectURL(blob);
  };
  const [mediaPlayerConnected, setMediaPlayerConnected] = createSignal(false);
  let unsubscribe: Dispose | undefined;

  createEffect(() => {
    if (!mediaPlayerConnected()) return;
    if (!video.value) return;
    document.addEventListener("keydown", handleKeyDown);  
    unsubscribe = mediaPlayer!.subscribe(({ paused, playing, }) => {
      console.log('Paused:', paused);
      // console.log('Playing:', playing);
    });
  });
  onCleanup(() => {
    unsubscribe?.();
  });
  const handleKeyDown = (e: KeyboardEvent) => {
    console.log(e.key);
    switch (e.key) {
      case "f":
        mediaPlayer?.requestFullscreen();
        e.preventDefault();
        break;
      case "m":
        mediaPlayer!.muted = !mediaPlayer!.muted;
        e.preventDefault();
        break;
      case "j":
        mediaPlayer!.currentTime = Math.max(mediaPlayer!.currentTime - 10, 0);
        e.preventDefault();
        break;
      case "l":
        mediaPlayer!.currentTime = Math.min(
          mediaPlayer!.currentTime + 10,
          video.value!.duration
        );
        e.preventDefault();
        break;
      case "c":
        // mediaPlayer!.textTracks
        e.preventDefault();
        break;
      case "k":
      case " ":
        if (mediaPlayer!.paused) mediaPlayer!.play();
        else mediaPlayer!.pause();
        e.preventDefault();
        break;
      // case "up":
      //   videoEl.volume = Math.min(videoEl.volume + 0.05, 1);
      //   e.preventDefault();
      //   break;
      // case "down":
      //   videoEl.volume = Math.max(videoEl.volume - 0.05, 0);
      //   e.preventDefault();
      //   break;
      case "ArrowLeft":
        mediaPlayer!.currentTime = Math.max(mediaPlayer!.currentTime - 5, 0);
        e.preventDefault();
        break;
      case "ArrowRight":
        mediaPlayer!.currentTime = mediaPlayer!.currentTime + 5;
        e.preventDefault();
        break;
      // case "0":
      //   videoEl.currentTime = 0;
      //   e.preventDefault();
      //   break;
      // case "1":
      //   videoEl.currentTime = videoEl.duration * 0.1;
      //   e.preventDefault();
      //   break;
      // case "2":
      //   videoEl.currentTime = videoEl.duration * 0.2;
      //   e.preventDefault();
      //   break;
      // case "3":
      //   videoEl.currentTime = videoEl.duration * 0.3;
      //   e.preventDefault();
      //   break;
      // case "4":
      //   videoEl.currentTime = videoEl.duration * 0.4;
      //   e.preventDefault();
      //   break;
      // case "5":
      //   videoEl.currentTime = videoEl.duration * 0.5;
      //   e.preventDefault();
      //   break;
      // case "6":
      //   videoEl.currentTime = videoEl.duration * 0.6;
      //   e.preventDefault();
      //   break;
      // case "7":
      //   videoEl.currentTime = videoEl.duration * 0.7;
      //   e.preventDefault();
      //   break;
      // case "8":
      //   videoEl.currentTime = videoEl.duration * 0.8;
      //   e.preventDefault();
      //   break;
      // case "9":
      //   videoEl.currentTime = videoEl.duration * 0.9;
      //   e.preventDefault();
      //   break;
      case "N":
        if (e.shiftKey) {
          playNext();
          e.preventDefault();
        }
        break;
      case "Escape":
        if (ended()) {
          dismiss();
          e.preventDefault();
        } else if (document.fullscreenElement) {
          mediaPlayer?.exitFullscreen();
          e.preventDefault();
        }
        break;

      case ",":
        mediaPlayer!.currentTime -= 0.04;
        break;
      case ".":
        mediaPlayer!.currentTime += 0.04;
        break;
      // case "return":
      //   self.skipSegment(videoEl);
      //   break;
    }
  };

  return (
    <media-player
      id="player"
      class={`peer pointer-events-auto`}
      current-time={currentTime()}
      // onTextTrackChange={handleTextTrackChange}
      load="eager"
      // key-shortcuts={{
      //   togglePaused: "k Space",
      //   toggleMuted: "m",
      //   toggleFullscreen: "f",
      //   togglePictureInPicture: "i",
      //   toggleCaptions: "c",
      //   seekBackward: "ArrowLeft h",
      //   seekForward: "ArrowRight l",
      //   volumeUp: "ArrowUp",
      //   volumeDown: "ArrowDown",
      // }}
      key-disabled
      on:can-play={onCanPlay}
      on:provider-change={onProviderChange}
      on:hls-error={handleHlsError}
      on:pause={updateProgress}
      on:seeked={updateProgress}
      on:ended={handleEnded}
      on:play={() => setStarted(true)}
      on:media-player-connect={() => setMediaPlayerConnected(true)}
      autoplay
      ref={mediaPlayer}
      title={video.value?.title ?? ""}
      // src={video.value?.hls ?? ""}
      poster={video.value?.thumbnailUrl ?? ""}
      //       aspect-ratio={video.value?.videoStreams?.[0]
      //           ? video.value.videoStreams[0]?.width /
      //             video.value.videoStreams[0]?.height
      //           :
      // 16 / 9}
      aspect-ratio={16 / 9}
      thumbnails={generateStoryboard(video.value?.previewFrames[1])}
      crossorigin="anonymous">
      <media-outlet
        // classList={{"relative min-h-0 max-h-16 pb-0 h-full": preferences.pip}}
        ref={outlet}>
        <media-poster alt={video.value?.title ?? ""} />
        {tracks().map((track) => {
          return (
            <track
              id={track.id}
              kind={track.kind as any}
              src={track.src}
              srclang={track.srcLang}
              label={track.label}
              data-type={track.dataType}
            />
          );
        })}
        <media-captions class="transition-[bottom] not-can-control:opacity-100 user-idle:opacity-100 not-user-idle:bottom-[80px]" />
        <source src={video.value!.hls} type="application/x-mpegurl" />
      </media-outlet>
      <Show when={error()}>
        {(err) => (
          <Show when={err().fatal}>
            <div
              // classList={{hidden: preferences.pip}}
              class="absolute top-0 right-0 w-full h-full opacity-100 pointer-events-auto bg-black/50">
              <div class="flex flex-col items-center justify-center w-full h-full gap-3">
                <div class="text-2xl font-bold text-white">
                  {error()?.name} {error()?.details}
                </div>
                <div class="flex flex-col">
                  <div class="text-lg text-white">{error()?.message}</div>
                  <div class="text-lg text-white">
                    Please try switching to a different instance or refresh the
                    page.
                  </div>
                </div>
                <div class="flex justify-center gap-2">
                  <button
                    class="px-4 py-2 text-lg text-white border border-white rounded-md"
                    // onClick={() => window.location.reload()}
                  >
                    Refresh
                  </button>
                  <button
                    class="px-4 py-2 text-lg text-white border border-white rounded-md"
                    onClick={() => {
                      setError(undefined);
                    }}>
                    Close
                  </button>
                </div>
              </div>
            </div>
          </Show>
        )}
      </Show>
      <Show when={showEndScreen() && nextVideo()}>
        <div class="absolute z-50 top-0 right-0 w-full h-full opacity-100 pointer-events-auto bg-black/50">
          <div class="flex flex-col items-center justify-center w-full h-full gap-3">
            <div class="text-2xl font-bold text-white">
              Playing next in {counter()} seconds
            </div>
            <div class="flex flex-col">
              <div class="text-lg text-white w-72">
                <VideoCard v={nextVideo()?.info ?? undefined} />
              </div>
            </div>
            <div class="flex justify-center gap-2">
              <button
                class="px-4 py-2 text-lg text-white border border-white rounded-md"
                onClick={() => {
                  dismiss();
                  playNext();
                }}>
                Play now (Shift + N)
              </button>
              <button
                class="px-4 py-2 text-lg text-white border border-white rounded-md"
                onClick={() => {
                  dismiss();
                }}>
                Dismiss (Esc)
              </button>
            </div>
          </div>
        </div>
      </Show>
      <PlayerSkin video={video.value} nextVideo={nextVideo()} />
      {/* <media-community-skin></media-community-skin> */}
    </media-player>
  );
}
