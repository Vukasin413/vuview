{"version":3,"file":"index-B3L84c1c.js","sources":["../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/subscribable.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/utils.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/focusManager.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/onlineManager.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/retryer.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/notifyManager.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/removable.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/query.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/queryCache.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/mutation.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/mutationCache.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/queryClient.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/queryObserver.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js","../../../../../node_modules/.pnpm/@tanstack+query-core@5.14.2/node_modules/@tanstack/query-core/build/modern/hydration.js","../../../../../node_modules/.pnpm/@tanstack+solid-query@5.14.2_solid-js@1.8.16/node_modules/@tanstack/solid-query/build/index.js"],"sourcesContent":["// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\nexport {\n  Subscribable\n};\n//# sourceMappingURL=subscribable.js.map","// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in window;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (typeof fetchStatus !== \"undefined\" && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (typeof ctor === \"undefined\") {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nexport {\n  addToEnd,\n  addToStart,\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  isPlainArray,\n  isPlainObject,\n  isServer,\n  isValidTimeout,\n  keepPreviousData,\n  matchMutation,\n  matchQuery,\n  noop,\n  partialMatchKey,\n  replaceData,\n  replaceEqualDeep,\n  scheduleMicrotask,\n  shallowEqualObjects,\n  sleep,\n  timeUntilStale\n};\n//# sourceMappingURL=utils.js.map","// src/focusManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar FocusManager = class extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    this.listeners.forEach((listener) => {\n      listener();\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\nexport {\n  FocusManager,\n  focusManager\n};\n//# sourceMappingURL=focusManager.js.map","// src/onlineManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar OnlineManager = class extends Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\nexport {\n  OnlineManager,\n  onlineManager\n};\n//# sourceMappingURL=onlineManager.js.map","// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class {\n  constructor(options) {\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== \"always\" && !onlineManager.isOnline();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      promiseResolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause();\n        if (canContinue) {\n          continueResolve(value);\n        }\n        return canContinue;\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\nexport {\n  CancelledError,\n  canFetch,\n  createRetryer,\n  isCancelledError\n};\n//# sourceMappingURL=retryer.js.map","// src/notifyManager.ts\nimport { scheduleMicrotask } from \"./utils.js\";\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  const batch = (callback) => {\n    let result;\n    transactions++;\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n      if (!transactions) {\n        flush();\n      }\n    }\n    return result;\n  };\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const batchCalls = (callback) => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  const setNotifyFunction = (fn) => {\n    notifyFn = fn;\n  };\n  const setBatchNotifyFunction = (fn) => {\n    batchNotifyFn = fn;\n  };\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n}\nvar notifyManager = createNotifyManager();\nexport {\n  createNotifyManager,\n  notifyManager\n};\n//# sourceMappingURL=notifyManager.js.map","// src/removable.ts\nimport { isServer, isValidTimeout } from \"./utils.js\";\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\nexport {\n  Removable\n};\n//# sourceMappingURL=removable.js.map","// src/query.ts\nimport { noop, replaceData, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.#setOptions(config.options);\n    this.#observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = config.state || getDefaultState(this.options);\n    this.state = this.#initialState;\n    this.scheduleGc();\n  }\n  #initialState;\n  #revertState;\n  #cache;\n  #promise;\n  #retryer;\n  #observers;\n  #defaultOptions;\n  #abortSignalConsumed;\n  get meta() {\n    return this.options.meta;\n  }\n  #setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false\n    );\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#observers.some((observer) => observer.getCurrentResult().isStale);\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter((x) => x !== observer);\n      if (!this.#observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.#observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#promise) {\n        this.#retryer?.continueRetry();\n        return this.#promise;\n      }\n    }\n    if (options) {\n      this.#setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.#setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext);\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`)\n        );\n      }\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return this.options.queryFn(\n        queryFnContext\n      );\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    this.#retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === \"undefined\") {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        this.setData(data);\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.#promise = this.#retryer.promise;\n    return this.#promise;\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode) ? \"fetching\" : \"paused\",\n            ...!state.dataUpdatedAt && {\n              error: null,\n              status: \"pending\"\n            }\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = typeof data !== \"undefined\";\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query\n};\n//# sourceMappingURL=query.js.map","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/mutation.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Removable } from \"./removable.js\";\nimport { canFetch, createRetryer } from \"./retryer.js\";\nvar Mutation = class extends Removable {\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#defaultOptions = config.defaultOptions;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  #observers;\n  #defaultOptions;\n  #mutationCache;\n  #retryer;\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    const executeMutation = () => {\n      this.#retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject(new Error(\"No mutationFn found\"));\n          }\n          return this.options.mutationFn(variables);\n        },\n        onFail: (failureCount, error) => {\n          this.#dispatch({ type: \"failed\", failureCount, error });\n        },\n        onPause: () => {\n          this.#dispatch({ type: \"pause\" });\n        },\n        onContinue: () => {\n          this.#dispatch({ type: \"continue\" });\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.#retryer.promise;\n    };\n    const restored = this.state.status === \"pending\";\n    try {\n      if (!restored) {\n        this.#dispatch({ type: \"pending\", variables });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this\n        );\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables\n          });\n        }\n      }\n      const data = await executeMutation();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSuccess?.(data, variables, this.state.context);\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\nexport {\n  Mutation,\n  getDefaultState\n};\n//# sourceMappingURL=mutation.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = [];\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #mutationId;\n  #resuming;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.push(mutation);\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    this.#mutations = this.#mutations.filter((x) => x !== mutation);\n    this.notify({ type: \"removed\", mutation });\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return this.#mutations;\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.#mutations.find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.#mutations.filter(\n      (mutation) => matchMutation(filters, mutation)\n    );\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    this.#resuming = (this.#resuming ?? Promise.resolve()).then(() => {\n      const pausedMutations = this.#mutations.filter((x) => x.state.isPaused);\n      return notifyManager.batch(\n        () => pausedMutations.reduce(\n          (promise, mutation) => promise.then(() => mutation.continue().catch(noop)),\n          Promise.resolve()\n        )\n      );\n    }).then(() => {\n      this.#resuming = void 0;\n    });\n    return this.#resuming;\n  }\n};\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = { pages: [], pageParams: [] };\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = context.options.queryFn || (() => Promise.reject(\n          new Error(`Missing queryFn: '${context.options.queryHash}'`)\n        ));\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(\n            queryFnContext\n          );\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam\n          );\n          const remainingPages = pages ?? oldPages.length;\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  );\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams\n  );\n}\nfunction hasNextPage(options, data) {\n  if (!data)\n    return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam)\n    return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1)\n      return;\n    this.#unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0)\n      return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  getQueryData(queryKey) {\n    return this.#queryCache.find({ queryKey })?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    return cachedData !== void 0 ? Promise.resolve(cachedData) : this.fetchQuery(options);\n  }\n  getQueriesData(filters) {\n    return this.getQueryCache().findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const query = this.#queryCache.find({ queryKey });\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (typeof data === \"undefined\") {\n      return void 0;\n    }\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.getQueryCache().findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    return this.#queryCache.find({ queryKey })?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters = {}, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters = {}, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters = {}, options) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (typeof defaultedOptions.retry === \"undefined\") {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  resumePausedMutations() {\n    return this.#mutationCache.resumePausedMutations();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...options?.queryKey && this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (typeof defaultedOptions.refetchOnReconnect === \"undefined\") {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (typeof defaultedOptions.throwOnError === \"undefined\") {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (typeof defaultedOptions.networkMode === \"undefined\" && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","// src/queryObserver.ts\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { canFetch } from \"./retryer.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.#currentQuery = void 0;\n    this.#currentQueryInitialState = void 0;\n    this.#currentResult = void 0;\n    this.#trackedProps = /* @__PURE__ */ new Set();\n    this.#client = client;\n    this.options = options;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery;\n  #currentQueryInitialState;\n  #currentResult;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps;\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    if (typeof this.options.enabled !== \"undefined\" && typeof this.options.enabled !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean\");\n    }\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n    this.#updateQuery();\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime\n    );\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let { error, errorUpdatedAt, fetchStatus, status } = state;\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? \"fetching\" : \"paused\";\n        if (!state.dataUpdatedAt) {\n          status = \"pending\";\n        }\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        fetchStatus = \"idle\";\n      }\n    }\n    if (options.select && typeof state.data !== \"undefined\") {\n      if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = state.data;\n    }\n    if (typeof options.placeholderData !== \"undefined\" && typeof data === \"undefined\" && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && typeof placeholderData !== \"undefined\") {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (typeof placeholderData !== \"undefined\") {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const result = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","// src/infiniteQueryObserver.ts\nimport { QueryObserver } from \"./queryObserver.js\";\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n} from \"./infiniteQueryBehavior.js\";\nvar InfiniteQueryObserver = class extends QueryObserver {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options, notifyOptions) {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior()\n      },\n      notifyOptions\n    );\n  }\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"forward\" }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"backward\" }\n      }\n    });\n  }\n  createResult(query, options) {\n    const { state } = query;\n    const result = super.createResult(query, options);\n    const { isFetching, isRefetching } = result;\n    const isFetchingNextPage = isFetching && state.fetchMeta?.fetchMore?.direction === \"forward\";\n    const isFetchingPreviousPage = isFetching && state.fetchMeta?.fetchMore?.direction === \"backward\";\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n};\nexport {\n  InfiniteQueryObserver\n};\n//# sourceMappingURL=infiniteQueryObserver.js.map","// src/hydration.ts\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...mutation.meta && { meta: mutation.meta }\n  };\n}\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...query.meta && { meta: query.meta }\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(\n    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []\n  );\n  const filterQuery = options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const queries = client.getQueryCache().getAll().flatMap((query) => filterQuery(query) ? [dehydrateQuery(query)] : []);\n  return { mutations, queries };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n        meta: dehydratedMutation.meta\n      },\n      dehydratedMutation.state\n    );\n  });\n  queries.forEach(({ queryKey, state, queryHash, meta }) => {\n    const query = queryCache.get(queryHash);\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        const { fetchStatus: _ignored, ...dehydratedQueryState } = state;\n        query.setState(dehydratedQueryState);\n      }\n      return;\n    }\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey,\n        queryHash,\n        meta\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        fetchStatus: \"idle\"\n      }\n    );\n  });\n}\nexport {\n  defaultShouldDehydrateMutation,\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate\n};\n//# sourceMappingURL=hydration.js.map","import { notifyManager, QueryClient as QueryClient$1, MutationObserver, replaceEqualDeep, QueriesObserver, hydrate, QueryObserver, InfiniteQueryObserver } from '@tanstack/query-core';\nexport * from '@tanstack/query-core';\nimport { batch, createContext, useContext, createRenderEffect, onCleanup, createMemo, createSignal, createComputed, on, createEffect, mergeProps, createResource, onMount, untrack } from 'solid-js';\nimport { createComponent, isServer } from 'solid-js/web';\nimport { createStore, unwrap, reconcile } from 'solid-js/store';\n\n// src/setBatchUpdatesFn.ts\nnotifyManager.setBatchNotifyFunction(batch);\nvar QueryClient = class extends QueryClient$1 {\n  constructor(config = {}) {\n    super(config);\n  }\n};\nvar QueryClientContext = createContext(void 0);\nvar useQueryClient = (queryClient) => {\n  if (queryClient) {\n    return queryClient;\n  }\n  const client = useContext(QueryClientContext);\n  if (!client) {\n    throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n  }\n  return client();\n};\nvar QueryClientProvider = (props) => {\n  createRenderEffect((unmount) => {\n    unmount?.();\n    props.client.mount();\n    return props.client.unmount.bind(props.client);\n  });\n  onCleanup(() => props.client.unmount());\n  return createComponent(QueryClientContext.Provider, {\n    value: () => props.client,\n    get children() {\n      return props.children;\n    }\n  });\n};\n\n// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nvar IsRestoringContext = createContext(() => false);\nvar useIsRestoring = () => useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\n\n// src/createBaseQuery.ts\nfunction reconcileFn(store, result, reconcileOption) {\n  if (reconcileOption === false)\n    return result;\n  if (typeof reconcileOption === \"function\") {\n    const newData2 = reconcileOption(store.data, result.data);\n    return { ...result, data: newData2 };\n  }\n  const newData = reconcile(result.data, { key: reconcileOption })(store.data);\n  return { ...result, data: newData };\n}\nvar hydrateableObserverResult = (query, result) => {\n  if (!isServer)\n    return result;\n  return {\n    ...unwrap(result),\n    // cast to refetch function should be safe, since we only remove it on the server,\n    // and refetch is not relevant on the server\n    refetch: void 0,\n    // hydrate() expects a QueryState object, which is similar but not\n    // quite the same as a QueryObserverResult object. Thus, for now, we're\n    // copying over the missing properties from state in order to support hydration\n    dataUpdateCount: query.state.dataUpdateCount,\n    fetchFailureCount: query.state.fetchFailureCount,\n    isInvalidated: query.state.isInvalidated,\n    // Unsetting these properties on the server since they might not be serializable\n    fetchFailureReason: null,\n    fetchMeta: null\n  };\n};\nfunction createBaseQuery(options, Observer, queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const isRestoring = useIsRestoring();\n  const defaultedOptions = createMemo(\n    () => mergeProps(client()?.defaultQueryOptions(options()) || {}, {\n      get _optimisticResults() {\n        return isRestoring() ? \"isRestoring\" : \"optimistic\";\n      },\n      structuralSharing: false,\n      ...isServer && { retry: false, throwOnError: true }\n    })\n  );\n  const [observer, setObserver] = createSignal(\n    new Observer(client(), untrack(defaultedOptions))\n  );\n  createComputed(\n    on(client, (c) => setObserver(new Observer(c, defaultedOptions())), {\n      defer: true\n    })\n  );\n  const [state, setState] = createStore(\n    observer().getOptimisticResult(defaultedOptions())\n  );\n  const createServerSubscriber = (resolve, reject) => {\n    return observer().subscribe((result) => {\n      notifyManager.batchCalls(() => {\n        const query = observer().getCurrentQuery();\n        const unwrappedResult = hydrateableObserverResult(query, result);\n        if (unwrappedResult.isError) {\n          reject(unwrappedResult.error);\n        } else {\n          resolve(unwrappedResult);\n        }\n      })();\n    });\n  };\n  const createClientSubscriber = () => {\n    const obs = observer();\n    return obs.subscribe((result) => {\n      notifyManager.batchCalls(() => {\n        const reconcileOptions = obs.options.reconcile;\n        setState((store) => {\n          return reconcileFn(\n            store,\n            result,\n            reconcileOptions === void 0 ? false : reconcileOptions\n          );\n        });\n        if (queryResource()?.data && result.data && !queryResource.loading && isRestoring())\n          mutate(state);\n        else\n          refetch();\n      })();\n    });\n  };\n  let unsubscribe = null;\n  const [queryResource, { refetch, mutate }] = createResource(\n    () => {\n      const obs = observer();\n      return new Promise((resolve, reject) => {\n        if (isServer)\n          unsubscribe = createServerSubscriber(resolve, reject);\n        else if (!unsubscribe && !isRestoring())\n          unsubscribe = createClientSubscriber();\n        obs.updateResult();\n        if (!state.isLoading && !isRestoring()) {\n          const query = obs.getCurrentQuery();\n          resolve(hydrateableObserverResult(query, state));\n        }\n      });\n    },\n    {\n      initialValue: state,\n      // If initialData is provided, we resolve the resource immediately\n      get ssrLoadFrom() {\n        return options().initialData ? \"initial\" : \"server\";\n      },\n      get deferStream() {\n        return options().deferStream;\n      },\n      /**\n       * If this resource was populated on the server (either sync render, or streamed in over time), onHydrated\n       * will be called. This is the point at which we can hydrate the query cache state, and setup the query subscriber.\n       *\n       * Leveraging onHydrated allows us to plug into the async and streaming support that solidjs resources already support.\n       *\n       * Note that this is only invoked on the client, for queries that were originally run on the server.\n       */\n      onHydrated(_k, info) {\n        const defaultOptions = defaultedOptions();\n        if (info.value) {\n          hydrate(client(), {\n            queries: [\n              {\n                queryKey: defaultOptions.queryKey,\n                queryHash: defaultOptions.queryHash,\n                state: info.value\n              }\n            ]\n          });\n        }\n        if (unsubscribe)\n          return;\n        const newOptions = { ...defaultOptions };\n        if (defaultOptions.staleTime || !defaultOptions.initialData) {\n          newOptions.refetchOnMount = false;\n        }\n        observer().setOptions(newOptions);\n        setState(observer().getOptimisticResult(newOptions));\n        unsubscribe = createClientSubscriber();\n      }\n    }\n  );\n  createComputed(\n    on(\n      [isRestoring, observer],\n      ([restoring]) => {\n        const unsub = unsubscribe;\n        queueMicrotask(() => unsub?.());\n        unsubscribe = null;\n        if (!restoring)\n          refetch();\n      },\n      { defer: true }\n    )\n  );\n  onCleanup(() => {\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = null;\n    }\n  });\n  createComputed(\n    on(\n      [observer, defaultedOptions],\n      ([obs, opts]) => {\n        obs.setOptions(opts);\n        setState(obs.getOptimisticResult(opts));\n      },\n      {\n        // Defer because we don't need to trigger on first render\n        // This only cares about changes to options after the observer is created\n        defer: true\n      }\n    )\n  );\n  createComputed(\n    on(\n      () => state.status,\n      () => {\n        const obs = observer();\n        if (state.isError && !state.isFetching && !isRestoring() && shouldThrowError(obs.options.throwOnError, [\n          state.error,\n          obs.getCurrentQuery()\n        ])) {\n          throw state.error;\n        }\n      }\n    )\n  );\n  const handler = {\n    get(target, prop) {\n      const val = queryResource()?.[prop];\n      return val !== void 0 ? val : Reflect.get(target, prop);\n    }\n  };\n  return new Proxy(state, handler);\n}\n\n// src/createQuery.ts\nfunction queryOptions(options) {\n  return options;\n}\nfunction createQuery(options, queryClient) {\n  return createBaseQuery(\n    createMemo(() => options()),\n    QueryObserver,\n    queryClient\n  );\n}\nfunction useIsFetching(filters, queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const queryCache = createMemo(() => client().getQueryCache());\n  const [fetches, setFetches] = createSignal(client().isFetching(filters?.()));\n  const unsubscribe = queryCache().subscribe(() => {\n    setFetches(client().isFetching(filters?.()));\n  });\n  onCleanup(unsubscribe);\n  return fetches;\n}\nfunction createInfiniteQuery(options, queryClient) {\n  return createBaseQuery(\n    createMemo(() => options()),\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nfunction createMutation(options, queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const observer = new MutationObserver(\n    client(),\n    options()\n  );\n  const mutate = (variables, mutateOptions) => {\n    observer.mutate(variables, mutateOptions).catch(noop);\n  };\n  const [state, setState] = createStore({\n    ...observer.getCurrentResult(),\n    mutate,\n    mutateAsync: observer.getCurrentResult().mutate\n  });\n  createComputed(() => {\n    observer.setOptions(options());\n  });\n  createComputed(\n    on(\n      () => state.status,\n      () => {\n        if (state.isError && shouldThrowError(observer.options.throwOnError, [state.error])) {\n          throw state.error;\n        }\n      }\n    )\n  );\n  const unsubscribe = observer.subscribe((result) => {\n    setState({\n      ...result,\n      mutate,\n      mutateAsync: result.mutate\n    });\n  });\n  onCleanup(unsubscribe);\n  return state;\n}\nfunction noop() {\n}\nfunction useIsMutating(filters, queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const mutationCache = createMemo(() => client().getMutationCache());\n  const [mutations, setMutations] = createSignal(\n    client().isMutating(filters?.())\n  );\n  const unsubscribe = mutationCache().subscribe((_result) => {\n    setMutations(client().isMutating(filters?.()));\n  });\n  onCleanup(unsubscribe);\n  return mutations;\n}\nfunction getResult(mutationCache, options) {\n  return mutationCache.findAll(options.filters).map(\n    (mutation) => options.select ? options.select(\n      mutation\n    ) : mutation.state\n  );\n}\nfunction useMutationState(options = () => ({}), queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const mutationCache = createMemo(() => client().getMutationCache());\n  const [result, setResult] = createSignal(\n    getResult(mutationCache(), options())\n  );\n  createEffect(() => {\n    const unsubscribe = mutationCache().subscribe(() => {\n      const nextResult = replaceEqualDeep(\n        result(),\n        getResult(mutationCache(), options())\n      );\n      if (result() !== nextResult) {\n        setResult(nextResult);\n      }\n    });\n    onCleanup(unsubscribe);\n  });\n  return result;\n}\nfunction createQueries(queriesOptions, queryClient) {\n  const client = createMemo(() => useQueryClient(queryClient?.()));\n  const isRestoring = useIsRestoring();\n  const defaultedQueries = createMemo(\n    () => queriesOptions().queries.map(\n      (options) => mergeProps(client().defaultQueryOptions(options), {\n        get _optimisticResults() {\n          return isRestoring() ? \"isRestoring\" : \"optimistic\";\n        }\n      })\n    )\n  );\n  const observer = new QueriesObserver(\n    client(),\n    defaultedQueries(),\n    queriesOptions().combine ? {\n      combine: queriesOptions().combine\n    } : void 0\n  );\n  const [state, setState] = createStore(\n    observer.getOptimisticResult(defaultedQueries())[1]()\n  );\n  createRenderEffect(\n    on(\n      () => queriesOptions().queries.length,\n      () => setState(observer.getOptimisticResult(defaultedQueries())[1]())\n    )\n  );\n  const dataResources = createMemo(\n    on(\n      () => state.length,\n      () => state.map((queryRes) => {\n        const dataPromise = () => new Promise((resolve) => {\n          if (queryRes.isFetching && queryRes.isLoading)\n            return;\n          resolve(unwrap(queryRes.data));\n        });\n        return createResource(dataPromise);\n      })\n    )\n  );\n  batch(() => {\n    const dataResources_ = dataResources();\n    for (let index = 0; index < dataResources_.length; index++) {\n      const dataResource = dataResources_[index];\n      dataResource[1].mutate(() => unwrap(state[index].data));\n      dataResource[1].refetch();\n    }\n  });\n  let taskQueue = [];\n  const subscribeToObserver = () => observer.subscribe((result) => {\n    taskQueue.push(() => {\n      batch(() => {\n        const dataResources_ = dataResources();\n        for (let index = 0; index < dataResources_.length; index++) {\n          const dataResource = dataResources_[index];\n          const unwrappedResult = { ...unwrap(result[index]) };\n          setState(index, unwrap(unwrappedResult));\n          dataResource[1].mutate(() => unwrap(state[index].data));\n          dataResource[1].refetch();\n        }\n      });\n    });\n    queueMicrotask(() => {\n      const taskToRun = taskQueue.pop();\n      if (taskToRun)\n        taskToRun();\n      taskQueue = [];\n    });\n  });\n  let unsubscribe = () => void 0;\n  createComputed((cleanup) => {\n    cleanup?.();\n    unsubscribe = isRestoring() ? () => void 0 : subscribeToObserver();\n    return () => queueMicrotask(unsubscribe);\n  });\n  onCleanup(unsubscribe);\n  onMount(() => {\n    observer.setQueries(\n      defaultedQueries(),\n      queriesOptions().combine ? {\n        combine: queriesOptions().combine\n      } : void 0,\n      { listeners: false }\n    );\n  });\n  createComputed(() => {\n    observer.setQueries(\n      defaultedQueries(),\n      queriesOptions().combine ? {\n        combine: queriesOptions().combine\n      } : void 0,\n      { listeners: false }\n    );\n  });\n  const handler = (index) => ({\n    get(target, prop) {\n      if (prop === \"data\") {\n        return dataResources()[index][0]();\n      }\n      return Reflect.get(target, prop);\n    }\n  });\n  const getProxies = () => state.map((s, index) => {\n    return new Proxy(s, handler(index));\n  });\n  const [proxifiedState, setProxifiedState] = createStore(getProxies());\n  createRenderEffect(() => setProxifiedState(getProxies()));\n  return proxifiedState;\n}\n\nexport { IsRestoringProvider, QueryClient, QueryClientContext, QueryClientProvider, createInfiniteQuery, createMutation, createQueries, createQuery, queryOptions, useIsFetching, useIsMutating, useIsRestoring, useMutationState, useQueryClient };\n"],"names":["Subscribable","constructor","listeners","Set","subscribe","bind","listener","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","ms","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","structuralSharing","addToEnd","items","item","newItems","slice","addToStart","FocusManager","#focused","#cleanup","#setup","onFocus","addEventListener","removeEventListener","setEventListener","setup","focused","setFocused","forEach","isFocused","globalThis","document","visibilityState","focusManager","OnlineManager","#online","onOnline","onlineListener","offlineListener","setOnline","online","isOnline","onlineManager","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","onSuccess","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","continue","createNotifyManager","queue","transactions","notifyFn","batchNotifyFn","batch","flush","schedule","push","batchCalls","args","originalQueue","setNotifyFunction","setBatchNotifyFunction","notifyManager","Removable","#gcTimeout","destroy","clearGcTimeout","scheduleGc","gcTime","optionalRemove","updateGcTime","newGcTime","clearTimeout","Query","#abortSignalConsumed","#defaultOptions","defaultOptions","#setOptions","#observers","#cache","cache","#initialState","getDefaultState","#revertState","#promise","#retryer","meta","remove","setData","newData","#dispatch","dataUpdatedAt","manual","setState","setStateOptions","reset","observer","enabled","isDisabled","getObserversCount","isInvalidated","getCurrentResult","isStaleByTime","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","shouldFetchOnReconnect","addObserver","includes","notify","removeObserver","filter","invalidate","fetch","fetchOptions","queryFn","abortController","AbortController","queryFnContext","addSignalProperty","object","defineProperty","enumerable","get","signal","fetchFn","persister","Error","context","behavior","onFetch","fetchMeta","onSettled","isFetchingOptimistic","action","reducer","fetchFailureCount","fetchFailureReason","dataUpdateCount","errorUpdateCount","errorUpdatedAt","onQueryUpdate","initialData","hasData","initialDataUpdatedAt","QueryCache","#queries","Map","build","client","defaultQueryOptions","getQueryDefaults","has","set","queryInMap","clear","getAll","values","defaultedFilters","findAll","queries","event","Mutation","mutationId","#mutationCache","mutationCache","setOptions","execute","variables","executeMutation","mutationFn","restored","onMutate","failureReason","isPaused","submittedAt","onMutationUpdate","MutationCache","#mutations","#mutationId","#resuming","defaultMutationOptions","resumePausedMutations","pausedMutations","infiniteQueryBehavior","pages","direction","fetchMore","oldPages","oldPageParams","pageParams","empty","cancelled","aborted","fetchPage","param","previous","pageParam","page","maxPages","addTo","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","initialPageParam","remainingPages","lastIndex","hasNextPage","hasPreviousPage","QueryClient","#queryCache","#queryDefaults","#mutationDefaults","#mountCount","#unsubscribeFocus","#unsubscribeOnline","queryCache","mount","unmount","isFetching","isMutating","getQueryData","ensureQueryData","cachedData","fetchQuery","getQueriesData","getQueryCache","map","setQueryData","defaultedOptions","setQueriesData","getQueryState","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","defaultedCancelOptions","promises","all","invalidateQueries","refetchType","throwOnError","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","defaults","queryDefault","setMutationDefaults","getMutationDefaults","_defaulted","refetchOnReconnect","suspense","mutations","QueryObserver","#currentQuery","#currentQueryInitialState","#currentResult","#trackedProps","#client","#selectError","bindMethods","#currentResultState","#currentResultOptions","#selectFn","#selectResult","#lastQueryWithDefinedData","#staleTimeoutId","#refetchIntervalId","#currentRefetchInterval","shouldFetchOnMount","#executeFetch","updateResult","#updateTimers","shouldFetchOn","refetchOnWindowFocus","#clearStaleTimeout","#clearRefetchInterval","notifyOptions","prevOptions","prevQuery","#updateQuery","mounted","shouldFetchOptionally","#updateStaleTimeout","nextRefetchInterval","#computeRefetchInterval","#updateRefetchInterval","getOptimisticResult","createResult","shouldAssignObserverCurrentProperties","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","timeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","select","selectError","placeholderData","isPending","isError","isLoading","isSuccess","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","typedKey","#notify","shouldLoadOnMount","retryOnMount","refetchOnMount","field","optimisticResult","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","isFetchingNextPage","isFetchingPreviousPage","hydrate","dehydratedState","dehydratedMutation","_ignored","dehydratedQueryState","QueryClient$1","QueryClientContext","createContext","useQueryClient","queryClient","useContext","QueryClientProvider","props","createRenderEffect","onCleanup","createComponent","Provider","children","shouldThrowError","throwError","params","IsRestoringContext","useIsRestoring","reconcileFn","store","reconcileOption","newData2","reconcile","hydrateableObserverResult","createBaseQuery","Observer","createMemo","isRestoring","mergeProps","setObserver","createSignal","untrack","createComputed","on","c","defer","createStore","createClientSubscriber","obs","reconcileOptions","queryResource","loading","mutate","unsubscribe","createResource","initialValue","ssrLoadFrom","deferStream","onHydrated","_k","info","newOptions","restoring","unsub","queueMicrotask","opts","handler","target","prop","Reflect","Proxy","createQuery","createInfiniteQuery"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}