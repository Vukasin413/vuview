{"version":3,"file":"Link-Dg-h0Eyu.js","sources":["../../../../../node_modules/.pnpm/solid-js@1.8.16/node_modules/solid-js/store/dist/store.js","../../../../../src/stores/appStateStore.tsx","../../../../../src/components/Link.tsx"],"sourcesContent":["import { $PROXY, $TRACK, getListener, batch, createSignal } from \"solid-js\";\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps$1))\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return (\n    obj != null &&\n    typeof obj === \"object\" &&\n    (obj[$PROXY] ||\n      !(proto = Object.getPrototypeOf(obj)) ||\n      proto === Object.prototype ||\n      Array.isArray(obj))\n  );\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if ((result = item != null && item[$RAW])) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes)\n    Object.defineProperty(target, symbol, {\n      value: (nodes = Object.create(null))\n    });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return (nodes[property] = s);\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (\n        getListener() &&\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\n        !(desc && desc.get)\n      )\n        value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const { from = 0, to = current.length - 1, by = 1 } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1\n        ? updateArray(unwrappedStore, args[0])\n        : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (\n    !desc ||\n    desc.get ||\n    desc.set ||\n    !desc.configurable ||\n    property === $PROXY ||\n    property === $NODE\n  )\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => (target[$PROXY][property] = v);\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getNode(nodes, property, value)();\n      else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps))\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass =\n      value !== null &&\n      typeof value === \"object\" &&\n      !Array.isArray(value) &&\n      proto !== Object.prototype;\n    if (isClass) {\n      const descriptors = Object.getOwnPropertyDescriptors(proto);\n      keys.push(...Object.keys(descriptors));\n      Object.assign(desc, descriptors);\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (\n    property !== $ROOT &&\n    (!isWrappable(target) ||\n      !isWrappable(previous) ||\n      isArray !== Array.isArray(previous) ||\n      (key && target[key] !== previous[key]))\n  ) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (\n      target.length &&\n      previous.length &&\n      (!merge || (key && target[0] && target[0][key] != null))\n    ) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (\n        start = 0, end = Math.min(previous.length, target.length);\n        start < end &&\n        (previous[start] === target[start] ||\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\n        start++\n      ) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (\n        end = previous.length - 1, newEnd = target.length - 1;\n        end >= start &&\n        newEnd >= start &&\n        (previous[end] === target[newEnd] ||\n          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));\n        end--, newEnd--\n      ) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const { merge, key = \"id\" } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(\n      v,\n      {\n        [$ROOT]: state\n      },\n      $ROOT,\n      merge,\n      key\n    );\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value)\n      ? producers.get(value) ||\n          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)\n      : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, (proxy = new Proxy(state, setterTraps)));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = undefined;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import { createContext, useContext } from \"solid-js\";\nimport { createStore } from \"solid-js/store\";\nimport { ProviderStatus } from \"~/components/Header\";\n\nconst store = createStore({\n  loading: false,\n  touchInProgress: false,\n  sync: {\n    providers: {\n      idb: \"disconnected\" as ProviderStatus,\n      webrtc: \"disconnected\" as ProviderStatus,\n      opfs: \"disconnected\" as ProviderStatus,\n    },\n    syncing: false,\n    lastSync: 0,\n    userId: 0,\n    users: [] as { id: number; name: string }[],\n  },\n  player: {\n    small: false,\n    dismissed: false,\n    lastVideoUrl: \"\",\n  }\n});\nconst AppStateContext = createContext(store);\nexport const AppStateProvider = (props: { children: any }) => {\n  return (\n    <AppStateContext.Provider value={store}>\n      {props.children}\n    </AppStateContext.Provider>\n  );\n};\nexport const useAppState = () => {\n  const context = useContext(AppStateContext);\n  return context;\n};\n","import { A, useSearchParams } from \"@solidjs/router\";\nimport { createEffect, createSignal } from \"solid-js\";\nimport { useAppState } from \"~/stores/appStateStore\";\n\nexport default function Link(props: LinkProps) {\n  const [searchParams] = useSearchParams();\n  const [href, setHref] = createSignal(props.href);\n  const [appState, setAppState] = useAppState();\n\n  createEffect(() => {\n    const fullscreen = searchParams.fullscreen === \"true\";\n    try {\n      const hrefUrl = new URL(`${window.location.origin}${props.href}`);\n      if (fullscreen) {\n        hrefUrl.searchParams.set(\"fullscreen\", \"true\");\n      } else {\n        hrefUrl.searchParams.delete(\"fullscreen\");\n      }\n      const relativePath = hrefUrl.pathname;\n\n      setHref(`${relativePath}${hrefUrl.search}${hrefUrl.hash}`);\n    } catch (e) {\n      console.error(e, props.href);\n    }\n  });\n\n  return (\n    <A\n      onClick={(e) => {\n        // hack to get around the touch events propagating down\n        if (appState.touchInProgress) {\n          e.preventDefault();\n          e.stopPropagation();\n          setTimeout(() => {\n            setAppState(\"touchInProgress\", false);\n          }, 100);\n        }\n      }}\n      href={href()}\n      class={props.class}\n      style={props.style}\n      activeClass={props.activeClass}\n      inactiveClass={props.inactiveClass}\n    >\n      {props.children}\n    </A>\n  );\n}\ninterface LinkProps {\n  href: string;\n  class?: string;\n  style?: any;\n  children?: any;\n  activeClass?: string;\n  inactiveClass?: string;\n}\n"],"names":["$RAW","Symbol","$NODE","$HAS","$SELF","wrap$1","value","p","$PROXY","Object","defineProperty","Proxy","proxyTraps$1","Array","isArray","keys","desc","getOwnPropertyDescriptors","i","l","length","prop","get","enumerable","bind","isWrappable","obj","proto","getPrototypeOf","prototype","unwrap","item","set","Set","result","unwrapped","v","has","isFrozen","slice","add","assign","getNodes","target","symbol","nodes","create","getNode","property","s","createSignal","equals","internal","$","proxyDescriptor$1","Reflect","getOwnPropertyDescriptor","configurable","writable","trackSelf","getListener","ownKeys","receiver","$TRACK","tracked","hasOwnProperty","deleteProperty","setProperty","state","deleting","prev","len","undefined","node","mergeStoreNode","key","updateArray","current","next","updatePath","path","traversed","part","shift","partType","concat","from","to","by","createStore","store","options","unwrappedStore","wrappedStore","setStore","args","batch","$ROOT","applyState","parent","merge","previous","j","start","end","newEnd","newIndicesNext","keyVal","Math","min","temp","newIndices","Map","targetKeys","previousKeys","reconcile","res","producers","WeakMap","setterTraps","proxy","produce","fn","loading","touchInProgress","sync","providers","idb","webrtc","opfs","syncing","lastSync","userId","users","player","small","dismissed","lastVideoUrl","AppStateContext","createContext","AppStateProvider","props","_$createComponent","Provider","children","useAppState","useContext","Link","searchParams","useSearchParams","href","setHref","appState","setAppState","createEffect","fullscreen","hrefUrl","URL","window","location","origin","delete","relativePath","pathname","search","hash","e","error","A","onClick","preventDefault","stopPropagation","setTimeout","class","style","activeClass","inactiveClass"],"mappings":"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","x_google_ignoreList":[0]}