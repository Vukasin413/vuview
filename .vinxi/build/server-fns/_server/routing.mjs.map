{"version":3,"file":"routing.mjs","sources":["../../../../node_modules/.pnpm/@solidjs+router@0.13.1_solid-js@1.8.16/node_modules/@solidjs/router/dist/lifecycle.js","../../../../node_modules/.pnpm/@solidjs+router@0.13.1_solid-js@1.8.16/node_modules/@solidjs/router/dist/utils.js","../../../../node_modules/.pnpm/@solidjs+router@0.13.1_solid-js@1.8.16/node_modules/@solidjs/router/dist/routing.js"],"sourcesContent":["import { isServer } from \"solid-js/web\";\nexport function createBeforeLeave() {\n    let listeners = new Set();\n    function subscribe(listener) {\n        listeners.add(listener);\n        return () => listeners.delete(listener);\n    }\n    let ignore = false;\n    function confirm(to, options) {\n        if (ignore)\n            return !(ignore = false);\n        const e = {\n            to,\n            options,\n            defaultPrevented: false,\n            preventDefault: () => (e.defaultPrevented = true)\n        };\n        for (const l of listeners)\n            l.listener({\n                ...e,\n                from: l.location,\n                retry: (force) => {\n                    force && (ignore = true);\n                    l.navigate(to, { ...options, resolve: false });\n                }\n            });\n        return !e.defaultPrevented;\n    }\n    return {\n        subscribe,\n        confirm\n    };\n}\n// The following supports browser initiated blocking (eg back/forward)\nlet depth;\nexport function saveCurrentDepth() {\n    if (!window.history.state || window.history.state._depth == null) {\n        window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, \"\");\n    }\n    depth = window.history.state._depth;\n}\nif (!isServer) {\n    saveCurrentDepth();\n}\nexport function keepDepth(state) {\n    return {\n        ...state,\n        _depth: window.history.state && window.history.state._depth\n    };\n}\nexport function notifyIfNotBlocked(notify, block) {\n    let ignore = false;\n    return () => {\n        const prevDepth = depth;\n        saveCurrentDepth();\n        const delta = prevDepth == null ? null : depth - prevDepth;\n        if (ignore) {\n            ignore = false;\n            return;\n        }\n        if (delta && block(delta)) {\n            ignore = true;\n            window.history.go(-delta);\n        }\n        else {\n            notify();\n        }\n    };\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nexport const mockBase = \"http://sr\";\nexport function normalizePath(path, omitSlash = false) {\n    const s = path.replace(trimPathRegex, \"$1\");\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalizePath(base);\n    const fromPath = from && normalizePath(from);\n    let result = \"\";\n    if (!fromPath || path.startsWith(\"/\")) {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return (result || \"/\") + normalizePath(path, !result);\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        params[key] = value;\n    });\n    return params;\n}\nexport function createMatcher(path, partial, matchFilters) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const locSegment = locSegments[i];\n            const dynamic = segment[0] === \":\";\n            const key = dynamic ? segment.slice(1) : segment;\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n                match.params[key] = locSegment;\n            }\n            else if (dynamic || !matchSegment(locSegment, segment)) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n            if (matchSegment(remainder, matchFilter(splat))) {\n                match.params[splat] = remainder;\n            }\n            else {\n                return null;\n            }\n        }\n        return match;\n    };\n}\nfunction matchSegment(input, filter) {\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\n    if (filter === undefined) {\n        return true;\n    }\n    else if (typeof filter === \"string\") {\n        return isEqual(filter);\n    }\n    else if (typeof filter === \"function\") {\n        return filter(input);\n    }\n    else if (Array.isArray(filter)) {\n        return filter.some(isEqual);\n    }\n    else if (filter instanceof RegExp) {\n        return filter.test(input);\n    }\n    return false;\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\") {\n            merged.delete(key);\n        }\n        else {\n            merged.set(key, String(value));\n        }\n    });\n    const s = merged.toString();\n    return s ? `?${s}` : \"\";\n}\nexport function expandOptionals(pattern) {\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n    if (!match)\n        return [pattern];\n    let prefix = pattern.slice(0, match.index);\n    let suffix = pattern.slice(match.index + match[0].length);\n    const prefixes = [prefix, (prefix += match[1])];\n    // This section handles adjacent optional params. We don't actually want all permuations since\n    // that will lead to equivalent routes which have the same number of params. For example\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n    // ensure predictability where earlier params have precidence.\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n        prefixes.push((prefix += match[1]));\n        suffix = suffix.slice(match[0].length);\n    }\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n","import { runWithOwner } from \"solid-js\";\nimport { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\nimport { isServer, getRequestEvent } from \"solid-js/web\";\nimport { createBeforeLeave } from \"./lifecycle.js\";\nimport { mockBase, createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"./utils.js\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"<A> and 'use' router primitives can be only used inside a Route.\");\nlet TempRoute;\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\nexport const useNavigate = () => useRouter().navigatorFactory();\nexport const useLocation = () => useRouter().location;\nexport const useIsRouting = () => useRouter().isRouting;\nexport const useMatch = (path, matchFilters) => {\n    const location = useLocation();\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n    return createMemo(() => {\n        for (const matcher of matchers()) {\n            const match = matcher(location.pathname);\n            if (match)\n                return match;\n        }\n    });\n};\nexport const useParams = () => useRouter().params;\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = untrack(() => location.pathname + mergeSearchString(location.search, params) + location.hash);\n        navigate(searchString, {\n            scroll: false,\n            resolve: false,\n            ...options\n        });\n    };\n    return [location.query, setSearchParams];\n};\nexport const useBeforeLeave = (listener) => {\n    const s = useRouter().beforeLeave.subscribe({\n        listener,\n        location: useLocation(),\n        navigate: useNavigate()\n    });\n    onCleanup(s);\n};\nexport function createRoutes(routeDef, base = \"\") {\n    const { component, load, children, info } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const shared = {\n        key: routeDef,\n        component,\n        load,\n        info\n    };\n    return asArray(routeDef.path).reduce((acc, path) => {\n        for (const originalPath of expandOptionals(path)) {\n            const path = joinPaths(base, originalPath);\n            let pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n            pattern = pattern\n                .split(\"/\")\n                .map((s) => {\n                return s.startsWith(\":\") || s.startsWith(\"*\") ? s : encodeURIComponent(s);\n            })\n                .join(\"/\");\n            acc.push({\n                ...shared,\n                originalPath,\n                pattern,\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n            });\n        }\n        return acc;\n    }, []);\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexport function createBranches(routeDef, base = \"\", stack = [], branches = []) {\n    const routeDefs = asArray(routeDef);\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === \"object\") {\n            if (!def.hasOwnProperty(\"path\"))\n                def.path = \"\";\n            const routes = createRoutes(def, base);\n            for (const route of routes) {\n                stack.push(route);\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n                if (def.children && !isEmptyArray) {\n                    createBranches(def.children, route.pattern, stack, branches);\n                }\n                else {\n                    const branch = createBranch([...stack], branches.length);\n                    branches.push(branch);\n                }\n                stack.pop();\n            }\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nexport function createLocation(path, state) {\n    const origin = new URL(mockBase);\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => url().pathname);\n    const search = createMemo(() => url().search, true);\n    const hash = createMemo(() => url().hash);\n    const key = () => \"\";\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\n    };\n}\nlet intent;\nexport function getIntent() {\n    return intent;\n}\nexport function createRouterContext(integration, branches, getContext, options = {}) {\n    const { signal: [source, setSource], utils = {} } = integration;\n    const parsePath = utils.parsePath || (p => p);\n    const renderPath = utils.renderPath || (p => p);\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\n    const basePath = resolvePath(\"\", options.base || \"\");\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, setIsRouting] = createSignal(false);\n    const start = async (callback) => {\n        setIsRouting(true);\n        try {\n            await startTransition(callback);\n        }\n        finally {\n            setIsRouting(false);\n        }\n    };\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state);\n    const referrers = [];\n    const submissions = createSignal(isServer ? initFromFlash() : []);\n    const matches = createMemo(() => getRouteMatches(branches(), location.pathname));\n    const params = createMemoObject(() => {\n        const m = matches();\n        const params = {};\n        for (let i = 0; i < m.length; i++) {\n            Object.assign(params, m[i].params);\n        }\n        return params;\n    });\n    const baseRoute = {\n        pattern: basePath,\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    createRenderEffect(() => {\n        const { value, state } = source();\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\n        untrack(() => {\n            if (value !== reference()) {\n                start(() => {\n                    intent = \"native\";\n                    setReference(value);\n                    setState(state);\n                    resetErrorBoundaries();\n                    submissions[1]([]);\n                }).then(() => {\n                    intent = undefined;\n                });\n            }\n        });\n    });\n    return {\n        base: baseRoute,\n        location,\n        params,\n        isRouting,\n        renderPath,\n        parsePath,\n        navigatorFactory,\n        matches,\n        beforeLeave,\n        preloadRoute,\n        singleFlight: options.singleFlight === undefined ? true : options.singleFlight,\n        submissions\n    };\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: true,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    const e = getRequestEvent();\n                    e && (e.response = { status: 302, headers: new Headers({ Location: resolvedTo }) });\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else if (beforeLeave.confirm(resolvedTo, options)) {\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\n                    start(() => {\n                        intent = \"navigate\";\n                        setReference(resolvedTo);\n                        setState(nextState);\n                        resetErrorBoundaries();\n                        submissions[1]([]);\n                    }).then(() => {\n                        if (referrers.length === len) {\n                            intent = undefined;\n                            navigateEnd({\n                                value: resolvedTo,\n                                state: nextState\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            if (next.value !== first.value || next.state !== first.state) {\n                setSource({\n                    ...next,\n                    replace: first.replace,\n                    scroll: first.scroll\n                });\n            }\n            referrers.length = 0;\n        }\n    }\n    function preloadRoute(url, preloadData) {\n        const matches = getRouteMatches(branches(), url.pathname);\n        const prevIntent = intent;\n        intent = \"preload\";\n        for (let match in matches) {\n            const { route, params } = matches[match];\n            route.component &&\n                route.component.preload &&\n                route.component.preload();\n            const { load } = route;\n            preloadData &&\n                load &&\n                runWithOwner(getContext(), () => load({\n                    params,\n                    location: {\n                        pathname: url.pathname,\n                        search: url.search,\n                        hash: url.hash,\n                        query: extractSearchParams(url),\n                        state: null,\n                        key: \"\"\n                    },\n                    intent: \"preload\"\n                }));\n        }\n        intent = prevIntent;\n    }\n    function initFromFlash() {\n        const e = getRequestEvent();\n        return (e && e.router && e.router.submission\n            ? [e.router.submission]\n            : []);\n    }\n}\nexport function createRouteContext(router, parent, outlet, match) {\n    const { base, location, params } = router;\n    const { pattern, component, load } = match().route;\n    const path = createMemo(() => match().path);\n    component &&\n        component.preload &&\n        component.preload();\n    const data = load ? load({ params, location, intent: intent || \"initial\" }) : undefined;\n    const route = {\n        parent,\n        pattern,\n        path,\n        outlet: () => component\n            ? createComponent(component, {\n                params,\n                location,\n                data,\n                get children() {\n                    return outlet();\n                }\n            })\n            : outlet(),\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    return route;\n}\n"],"names":["createBeforeLeave","listeners","Set","subscribe","listener","add","delete","ignore","confirm","to","options","e","defaultPrevented","preventDefault","l","from","location","retry","force","navigate","resolve","depth","saveCurrentDepth","window","history","state","_depth","replaceState","length","isServer","keepDepth","notifyIfNotBlocked","notify","block","prevDepth","delta","go","hasSchemeRegex","trimPathRegex","mockBase","normalizePath","path","omitSlash","s","replace","test","resolvePath","base","basePath","fromPath","result","startsWith","toLowerCase","indexOf","invariant","value","message","Error","joinPaths","extractSearchParams","url","params","searchParams","forEach","key","createMatcher","partial","matchFilters","pattern","splat","split","segments","filter","Boolean","len","locSegments","lenDiff","undefined","match","matchFilter","i","segment","locSegment","dynamic","slice","matchSegment","remainder","join","input","isEqual","localeCompare","sensitivity","Array","isArray","some","RegExp","scoreRoute","route","reduce","score","createMemoObject","fn","map","Map","owner","getOwner","Proxy","get","_","property","has","runWithOwner","set","createMemo","getOwnPropertyDescriptor","enumerable","configurable","ownKeys","Reflect","mergeSearchString","search","merged","URLSearchParams","Object","entries","String","toString","expandOptionals","exec","prefix","index","suffix","prefixes","push","results","expansion","p","MAX_REDIRECTS","RouterContextObj","createContext","RouteContextObj","useRouter","useContext","useRoute","useResolvedPath","useHref","router","to_","renderPath","useNavigate","navigatorFactory","useLocation","useIsRouting","isRouting","useSearchParams","setSearchParams","searchString","untrack","pathname","hash","scroll","query","createRoutes","routeDef","component","load","children","info","isLeaf","shared","asArray","acc","originalPath","encodeURIComponent","matcher","createBranch","routes","matches","unshift","createBranches","stack","branches","routeDefs","def","hasOwnProperty","isEmptyArray","branch","pop","sort","a","b","getRouteMatches","createLocation","origin","URL","prev","path_","console","error","equals","href","on","intent","createRouterContext","integration","getContext","signal","source","setSource","utils","parsePath","beforeLeave","setIsRouting","createSignal","start","callback","startTransition","reference","setReference","setState","referrers","submissions","initFromFlash","m","assign","baseRoute","outlet","createRenderEffect","resetErrorBoundaries","then","preloadRoute","singleFlight","navigateFromRoute","warn","nextState","resolvedTo","current","getRequestEvent","response","status","headers","Headers","Location","navigateEnd","next","first","preloadData","prevIntent","preload","submission","createRouteContext","parent","data","createComponent"],"mappings":"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","x_google_ignoreList":[0,1,2]}