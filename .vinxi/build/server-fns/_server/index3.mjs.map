{"version":3,"file":"index3.mjs","sources":["../../../../node_modules/.pnpm/@solidjs+meta@0.28.6_solid-js@1.8.16/node_modules/@solidjs/meta/dist/index.jsx"],"sourcesContent":["import { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst getTagType = (tag) => tag.tag + (tag.name ? `.${tag.name}\"` : \"\");\nconst MetaProvider = props => {\n    if (!isServer && !sharedConfig.context) {\n        const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n        // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n        Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n    }\n    const cascadedTagInstances = new Map();\n    // TODO: use one element for all tags of the same type, just swap out\n    // where the props get applied\n    function getElement(tag) {\n        if (tag.ref) {\n            return tag.ref;\n        }\n        let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n        if (el) {\n            if (el.tagName.toLowerCase() !== tag.tag) {\n                if (el.parentNode) {\n                    // remove the old tag\n                    el.parentNode.removeChild(el);\n                }\n                // add the new tag\n                el = document.createElement(tag.tag);\n            }\n            // use the old tag\n            el.removeAttribute(\"data-sm\");\n        }\n        else {\n            // create a new tag\n            el = document.createElement(tag.tag);\n        }\n        return el;\n    }\n    const actions = {\n        addClientTag: (tag) => {\n            let tagType = getTagType(tag);\n            if (cascadingTags.indexOf(tag.tag) !== -1) {\n                //  only cascading tags need to be kept as singletons\n                if (!cascadedTagInstances.has(tagType)) {\n                    cascadedTagInstances.set(tagType, []);\n                }\n                let instances = cascadedTagInstances.get(tagType);\n                let index = instances.length;\n                instances = [...instances, tag];\n                // track indices synchronously\n                cascadedTagInstances.set(tagType, instances);\n                if (!isServer) {\n                    let element = getElement(tag);\n                    tag.ref = element;\n                    spread(element, tag.props);\n                    let lastVisited = null;\n                    for (var i = index - 1; i >= 0; i--) {\n                        if (instances[i] != null) {\n                            lastVisited = instances[i];\n                            break;\n                        }\n                    }\n                    if (element.parentNode != document.head) {\n                        document.head.appendChild(element);\n                    }\n                    if (lastVisited && lastVisited.ref) {\n                        document.head.removeChild(lastVisited.ref);\n                    }\n                }\n                return index;\n            }\n            if (!isServer) {\n                let element = getElement(tag);\n                tag.ref = element;\n                spread(element, tag.props);\n                if (element.parentNode != document.head) {\n                    document.head.appendChild(element);\n                }\n            }\n            return -1;\n        },\n        removeClientTag: (tag, index) => {\n            const tagName = getTagType(tag);\n            if (tag.ref) {\n                const t = cascadedTagInstances.get(tagName);\n                if (t) {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                        for (let i = index - 1; i >= 0; i--) {\n                            if (t[i] != null) {\n                                document.head.appendChild(t[i].ref);\n                            }\n                        }\n                    }\n                    t[index] = null;\n                    cascadedTagInstances.set(tagName, t);\n                }\n                else {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                    }\n                }\n            }\n        }\n    };\n    if (isServer) {\n        actions.addServerTag = (tagDesc) => {\n            const { tags = [] } = props;\n            // tweak only cascading tags\n            if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n                const index = tags.findIndex(prev => {\n                    const prevName = prev.props.name || prev.props.property;\n                    const nextName = tagDesc.props.name || tagDesc.props.property;\n                    return prev.tag === tagDesc.tag && prevName === nextName;\n                });\n                if (index !== -1) {\n                    tags.splice(index, 1);\n                }\n            }\n            tags.push(tagDesc);\n        };\n        if (Array.isArray(props.tags) === false) {\n            throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n        }\n    }\n    return <MetaContext.Provider value={actions}>{props.children}</MetaContext.Provider>;\n};\nconst MetaTag = (tag, props, setting) => {\n    const id = createUniqueId();\n    const c = useContext(MetaContext);\n    if (!c)\n        throw new Error(\"<MetaProvider /> should be in the tree\");\n    useHead({\n        tag,\n        props,\n        setting,\n        id,\n        get name() {\n            return props.name || props.property;\n        }\n    });\n    return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n    const { addClientTag, removeClientTag, addServerTag } = useContext(MetaContext);\n    createRenderEffect(() => {\n        if (!isServer) {\n            let index = addClientTag(tagDesc);\n            onCleanup(() => removeClientTag(tagDesc, index));\n        }\n    });\n    if (isServer) {\n        addServerTag(tagDesc);\n        return null;\n    }\n}\nexport function renderTags(tags) {\n    return tags\n        .map(tag => {\n        const keys = Object.keys(tag.props);\n        const props = keys\n            .map(k => k === \"children\"\n            ? \"\"\n            : ` ${k}=\"${\n            // @ts-expect-error\n            escape(tag.props[k], true)}\"`)\n            .join(\"\");\n        const children = tag.props.children;\n        if (tag.setting?.close) {\n            return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n            // @ts-expect-error\n            tag.setting?.escape ? escape(children) : children || \"\"}</${tag.tag}>`;\n        }\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n    })\n        .join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, { escape: true, close: true });\nexport const Style = props => MetaTag(\"style\", props, { close: true });\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => <Link rel=\"stylesheet\" {...props}/>;\n"],"names":["MetaContext","createContext","cascadingTags","getTagType","tag","name","MetaProvider","props","isServer","sharedConfig","context","ssrTags","document","head","querySelectorAll","prototype","forEach","call","ssrTag","parentNode","removeChild","cascadedTagInstances","Map","getElement","ref","el","querySelector","id","tagName","toLowerCase","createElement","removeAttribute","actions","addClientTag","tagType","indexOf","has","set","instances","get","index","length","element","lastVisited","i","appendChild","removeClientTag","t","addServerTag","tagDesc","tags","findIndex","prev","prevName","property","nextName","splice","push","Array","isArray","Error","_$createComponent","Provider","value","children","MetaTag","setting","createUniqueId","useContext","useHead","createRenderEffect","onCleanup","Title","escape","close"],"mappings":"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","x_google_ignoreList":[0]}